This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/tcg/characters/**/*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  tcg/
    characters/
      characterData/
        characters/
          statsUtil/
            getStats.ts
          Aura.ts
          Denken.ts
          Edel.ts
          Fern.ts
          Flamme.ts
          Frieren.ts
          Himmel.ts
          Laufen.ts
          Linie.ts
          Methode.ts
          Sein.ts
          Sense.ts
          Serie.ts
          Stark.ts
          Stille.ts
          Ubel.ts
          Wirbel.ts
        characterUtil/
          auraPlatoon.ts
        characterData.ts
      metadata/
        CharacterName.ts
      characterList.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/tcg/characters/characterData/characters/statsUtil/getStats.ts">
import { readFileSync } from "fs";
import path from "path";

export function getStats() {
  const jsonPath = "../characterStats.json";
  const statsPath = path.join(__dirname, jsonPath);
  const stats = JSON.parse(readFileSync(statsPath, "utf8"));

  return stats;
}
</file>

<file path="src/tcg/characters/characterData/characters/Aura.ts">
import { CharacterData } from "../characterData";
import Stats, { StatsEnum } from "@tcg/stats";
import { CharacterName } from "../../metadata/CharacterName";
import { CharacterEmoji } from "@tcg/formatting/emojis";
import Pronouns from "@tcg/pronoun";
import mediaLinks from "@tcg/formatting/mediaLinks";
import { AuraPlatoon } from "../characterUtil/auraPlatoon";
import TimedEffect from "@/src/tcg/timedEffect";
import { TCGThread } from "@/src/tcgChatInteractions/sendGameMessage";
import CommonCardAction from "@/src/tcg/util/commonCardActions";
import Game from "@/src/tcg/game";
import auraDeck from "@/src/tcg/decks/AuraDeck";

const INITIAL_ARMY_STRENGTH = 60;

const INITIAL_SWORDSMEN_COUNT = 2;
export const SWORDSMEN_DAMAGE = 3;

const INITIAL_SHIELDBEARERS_COUNT = 2;
export const SHIELDBEARERS_STRENGTH_RECOVERY = 2;

const INITIAL_ARCHERS_COUNT = 2;
export const ARCHERS_DAMAGE = 1;
export const ARCHERS_PIERCE = 0.0;

const auraStats = new Stats({
  [StatsEnum.HP]: 60.0,
  [StatsEnum.ATK]: 10.0,
  [StatsEnum.DEF]: 10.0,
  [StatsEnum.TrueDEF]: 0.0,
  [StatsEnum.SPD]: 10.0,
  [StatsEnum.Ability]: 0.0,
});

const Aura = new CharacterData({
  characterName: CharacterName.Aura,
  cosmetic: {
    pronouns: Pronouns.Feminine,
    emoji: CharacterEmoji.AURA,
    color: 0xcb83b8,
    imageUrl: mediaLinks.auraPortrait,
  },
  stats: auraStats,
  cards: auraDeck,
  ability: {
    abilityName: "Until the End of Time",
    abilityEffectString: `Aura controls an undead army to do her bidding. 50% of the damage targetted towards her will be transferred to the army instead.
        Aura starts with ${INITIAL_ARMY_STRENGTH} Army Strength, 2 Swordsmen platoons, 2 Shieldbearers platoons and 2 Archers platoons.
        At the end of every turn, Aura loses soldiers by order she summoned them until #Soldier x 10 <= Army Strength`,
    abilityStartOfTurnEffect: (game, characterIndex, messageCache) => {
      const self = game.getCharacter(characterIndex);

      if (game.turnCount === 1) {
        self.adjustStat(INITIAL_ARMY_STRENGTH, StatsEnum.Ability, game);

        const initialPlatoons = [
          ...new Array(INITIAL_SWORDSMEN_COUNT).fill(AuraPlatoon.Swordsmen),
          ...new Array(INITIAL_SHIELDBEARERS_COUNT).fill(
            AuraPlatoon.Shieldbearers
          ),
          ...new Array(INITIAL_ARCHERS_COUNT).fill(AuraPlatoon.Archers),
        ];
        for (let i = initialPlatoons.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [initialPlatoons[i], initialPlatoons[j]] = [
            initialPlatoons[j],
            initialPlatoons[i],
          ];
        }
        self.additionalMetadata.auraPlatoonQueue = initialPlatoons;
      }

      // apply effect if turn not skipped
      if (!self.skipTurn) {
        const opponent = game.getCharacter(1 - characterIndex);

        const swordsmenCount = self.additionalMetadata.auraPlatoonQueue.filter(
          (p) => p === AuraPlatoon.Swordsmen
        ).length;
        if (swordsmenCount > 0) {
          const swordsmenDamage = SWORDSMEN_DAMAGE * swordsmenCount;
          self.timedEffects.push(
            new TimedEffect({
              name: "Undead Swordsmen",
              description: `Deal ${swordsmenDamage} at turn's end.`,
              turnDuration: 1,
              executeEndOfTimedEffectActionOnRemoval: false,
              endOfTurnAction: function (
                this: TimedEffect,
                _game,
                _characterIndex
              ) {
                messageCache.push(
                  `The undead swordsmen swing blindly.`,
                  TCGThread.Gameroom
                );
                CommonCardAction.commonAttack(game, characterIndex, {
                  damage: swordsmenDamage,
                  isTimedEffectAttack: true,
                });
                const auraRotDamage =
                  self.additionalMetadata.auraRotDamage ?? 0;
                if (auraRotDamage > 0) {
                  opponent.adjustStat(-auraRotDamage, StatsEnum.HP, game);
                }
              },
            })
          );
        }

        const shieldbearersCount =
          self.additionalMetadata.auraPlatoonQueue.filter(
            (p) => p === AuraPlatoon.Shieldbearers
          ).length;
        if (shieldbearersCount > 0) {
          self.adjustStat(
            SHIELDBEARERS_STRENGTH_RECOVERY * shieldbearersCount,
            StatsEnum.Ability,
            game
          );
        }

        const archersCount = self.additionalMetadata.auraPlatoonQueue.filter(
          (p) => p === AuraPlatoon.Archers
        ).length;
        if (archersCount > 0) {
          self.timedEffects.push(
            new TimedEffect({
              name: "Undead Archers",
              description: `Deal ${ARCHERS_DAMAGE} DMG x ${archersCount} Times at turn's end.`,
              turnDuration: 1,
              endOfTurnAction: () => {
                messageCache.push(
                  `The undead archers fire a volley.`,
                  TCGThread.Gameroom
                );
                const auraRotDamage =
                  self.additionalMetadata.auraRotDamage ?? 0;

                for (let i = 0; i < archersCount; i++) {
                  CommonCardAction.commonAttack(game, characterIndex, {
                    damage: ARCHERS_DAMAGE,
                    isTimedEffectAttack: true,
                    // additionalPierceFactor: ARCHERS_PIERCE,
                  });
                  if (auraRotDamage > 0) {
                    opponent.adjustStat(-auraRotDamage, StatsEnum.HP, game);
                  }
                }
              },
            })
          );
        }
      }
    },
    abilityAfterOwnCardUse: function (
      game,
      characterIndex,
      _messageCache,
      card
    ) {
      const character = game.getCharacter(characterIndex);
      if (card.cardMetadata.armyStrength) {
        character.adjustStat(
          card.cardMetadata.armyStrength,
          StatsEnum.Ability,
          game
        );
      }
    },
    abilityDefendEffect: (
      game: Game,
      characterIndex: number,
      _messageCache,
      _attackDamage
    ) => {
      // damage calculation routine is done in game.ts
      const character = game.getCharacter(characterIndex);
      const damageAbsorbtion =
        character.additionalMetadata.auraArmyDamageAbsorbtion;
      character.additionalMetadata.defenderDamageScaling =
        1.0 - damageAbsorbtion;
    },
    abilityEndOfTurnEffect(this, game, characterIndex, messageCache) {
      const self = game.getCharacter(characterIndex);
      const queue = self.additionalMetadata.auraPlatoonQueue;
      let removeCount = 0;

      while ((queue.length - removeCount) * 10 > self.stats.stats.Ability) {
        const removedPlatoon = queue[removeCount];
        if (removedPlatoon) {
          switch (removedPlatoon) {
            case AuraPlatoon.Swordsmen:
              messageCache.push(
                `${self.name}'s undead swordsmen fall.`,
                TCGThread.Gameroom
              );
              self.adjustStat(-2, StatsEnum.ATK, game);
              break;
            case AuraPlatoon.Shieldbearers:
              messageCache.push(
                `${self.name}'s undead shieldbearers fall.`,
                TCGThread.Gameroom
              );
              self.adjustStat(-2, StatsEnum.DEF, game);
              break;
            case AuraPlatoon.Archers:
              messageCache.push(
                `${self.name}'s undead archers fall.`,
                TCGThread.Gameroom
              );
              self.adjustStat(-2, StatsEnum.SPD, game);
              break;
          }
          removeCount++;
        } else {
          break;
        }
      }

      // Remove processed elements once at the end
      if (removeCount > 0) {
        self.additionalMetadata.auraPlatoonQueue = queue.slice(removeCount);
      }
    },
  },
  additionalMetadata: {
    auraArmyDamageAbsorbed: true,
    auraArmyDamageAbsorbtion: 0.5,
    auraRotDamage: 0.0,
  },
});

export default Aura;
</file>

<file path="src/tcg/characters/characterData/characters/Denken.ts">
import { CharacterData } from "../characterData";
import Stats, { StatsEnum } from "@tcg/stats";
import { CharacterName } from "../../metadata/CharacterName";
import { CharacterEmoji } from "@tcg//formatting/emojis";
import denkenDeck from "@decks/DenkenDeck";
import { TCGThread } from "@src/tcgChatInteractions/sendGameMessage";
import Pronouns from "@tcg/pronoun";
import mediaLinks from "@tcg/formatting/mediaLinks";

const DENKEN_PRESERVERANCE_COUNT = 3;
export const DENKEN_DEATH_HP = -40;

const denkenStats = new Stats({
  [StatsEnum.HP]: 100.0,
  [StatsEnum.ATK]: 12.0,
  [StatsEnum.DEF]: 10.0,
  [StatsEnum.TrueDEF]: 0.0,
  [StatsEnum.SPD]: 10.0,
  [StatsEnum.Ability]: DENKEN_PRESERVERANCE_COUNT,
});

const Denken = new CharacterData({
  characterName: CharacterName.Denken,
  cosmetic: {
    pronouns: Pronouns.Masculine,
    emoji: CharacterEmoji.DENKEN,
    color: 0x82574f,
    imageUrl: mediaLinks.denkenPortrait,
  },
  stats: denkenStats,
  cards: denkenDeck,
  ability: {
    abilityName: "Preserverance",
    abilityEffectString: `This character starts with ${DENKEN_PRESERVERANCE_COUNT} Preserverance stacks.
    1 Stack is taken away when the character's HP is <= 0 at the end of the turn. 
    An additional stack is taken away when the character's HP is <= ${DENKEN_DEATH_HP / 2}. 
    The character loses when the number of Preserverance stack is 0, or if the character's HP is <= ${DENKEN_DEATH_HP}.`,
    abilityEndOfTurnEffect: function (
      this,
      game,
      characterIndex,
      messageCache
    ) {
      const character = game.characters[characterIndex];

      if (character.stats.stats.HP <= 0) {
        character.adjustStat(-1, StatsEnum.Ability, game);

        if (character.stats.stats.HP <= DENKEN_DEATH_HP / 2) {
          character.adjustStat(-1, StatsEnum.Ability, game);
        }

        if (character.stats.stats.Ability > 0) {
          messageCache.push(`Denken steels himself!`, TCGThread.Gameroom);
        } else {
          messageCache.push(`Denken's strength fades.`, TCGThread.Gameroom);
          game.additionalMetadata.forfeited[characterIndex] = true;
        }
      }
    },
  },
});

export default Denken;
</file>

<file path="src/tcg/characters/characterData/characters/Edel.ts">
import Stats, { StatsEnum } from "@tcg/stats";
import { CharacterName } from "@tcg/characters/metadata/CharacterName";
import { CharacterData } from "@tcg/characters/characterData/characterData";
import { CharacterEmoji } from "@tcg/formatting/emojis";
import edelDeck from "@tcg/decks/EdelDeck";
import Pronouns from "@tcg/pronoun";
import { TCGThread } from "@src/tcgChatInteractions/sendGameMessage";
import mediaLinks from "@tcg/formatting/mediaLinks";
import Game from "@tcg/game";
import { MessageCache } from "@src/tcgChatInteractions/messageCache";
import Card from "@tcg/card";

const edelStats = new Stats({
  [StatsEnum.HP]: 80,
  [StatsEnum.ATK]: 8,
  [StatsEnum.DEF]: 8,
  [StatsEnum.TrueDEF]: 0.0,
  [StatsEnum.SPD]: 10,
  [StatsEnum.Ability]: 0,
});

const Edel = new CharacterData({
  characterName: CharacterName.Edel,
  cosmetic: {
    pronouns: Pronouns.Feminine,
    emoji: CharacterEmoji.EDEL,
    color: 0xae9292,
    imageUrl: mediaLinks.edelPortrait,
  },
  stats: edelStats,
  cards: edelDeck,
  ability: {
    abilityName: "A Superior Opponent",
    abilityEffectString:
      "While you make Eye Contact with the opponent, all your moves have Priority+1",
    subAbilities: [
      {
        name: "Memory Transference Specialist",
        description: "Your opponent's discards are visible.",
      },
    ],
    abilityStartOfTurnEffect: (game, characterIndex, messageCache) => {
      const self = game.getCharacter(characterIndex);
      const opponent = game.getCharacter(1 - characterIndex);

      opponent.additionalMetadata.publicDiscards = true; // enables Memory Transference Specialist

      // A Superior Opponent
      if (self.stats.stats.Ability > 0) {
        self.adjustStat(-1, StatsEnum.Ability, game);
        messageCache.push(
          `${self.name} made eye contact with ${opponent.name} - ${self.cosmetic.pronouns.possessive} moves gain **Priority+1**.`,
          TCGThread.Gameroom
        );

        self.ability.abilitySelectedMoveModifierEffect = (
          _game,
          _characterIndex,
          _messageCache,
          card
        ) => {
          card.priority += 1;
          return card;
        };
      } else {
        self.ability.abilitySelectedMoveModifierEffect = undefined;
      }
    },
    abilityAfterOwnCardUse: function (
      game: Game,
      characterIndex: number,
      _messageCache: MessageCache,
      card: Card
    ) {
      const character = game.getCharacter(characterIndex);
      if (card.cardMetadata.edelEyeContact) {
        character.adjustStat(
          card.cardMetadata.edelEyeContact,
          StatsEnum.Ability,
          game
        );
      }
    },
  },
  additionalMetadata: {
    methodeFindsCute: true,
  },
});

export default Edel;
</file>

<file path="src/tcg/characters/characterData/characters/Fern.ts">
import { CharacterData } from "../characterData";
import Stats, { StatsEnum } from "@tcg/stats";
import { CharacterName } from "../../metadata/CharacterName";
import { CharacterEmoji } from "@tcg/formatting/emojis";
import fernDeck from "@decks/FernDeck";
import Pronouns from "@tcg/pronoun";
import mediaLinks from "@tcg/formatting/mediaLinks";

const fernStats = new Stats({
  [StatsEnum.HP]: 100.0,
  [StatsEnum.ATK]: 12.0,
  [StatsEnum.DEF]: 10.0,
  [StatsEnum.TrueDEF]: 0.0,
  [StatsEnum.SPD]: 14.0,
  [StatsEnum.Ability]: 0.0,
});

const Fern = new CharacterData({
  characterName: CharacterName.Fern,
  cosmetic: {
    pronouns: Pronouns.Feminine,
    emoji: CharacterEmoji.FERN,
    color: 0x8e528e,
    imageUrl: mediaLinks.fernPortrait,
  },
  stats: fernStats,
  cards: fernDeck,
  ability: {
    abilityName: "Prodigy",
    abilityEffectString:
      "One random card in your hand gets empowered every turn.",
    subAbilities: [
      {
        name: "Mana Suppression",
        description: "Hide the amount of HP this character has.",
      },
      {
        name: "Keen Eye",
        description: "See past the opponent's Mana Suppression.",
      },
    ],
    abilityStartOfTurnEffect(
      game,
      characterIndex,
      messageCache,
      _additionalParam
    ) {
      // get a random card from hand
      const character = game.getCharacter(characterIndex);
      const hand = character.hand;
      const randomIndex = Math.floor(Math.random() * hand.length);
      const selectedCard = hand[randomIndex];

      selectedCard.empowerLevel += 1;
      messageCache.push(
        `## ${character.name} empowered ${selectedCard.title} to +${selectedCard.empowerLevel}`,
        character.characterThread
      );
    },
  },
  additionalMetadata: {
    manaSuppressed: true,
    ignoreManaSuppressed: true,
    fernBarrage: 0,
    methodeFindsCute: true,
  },
});

export default Fern;
</file>

<file path="src/tcg/characters/characterData/characters/Flamme.ts">
import { CharacterData } from "../characterData";
import Stats, { StatsEnum } from "@tcg/stats";
import flammeDeck from "@tcg/decks/FlammeDeck";
import { CharacterName } from "../../metadata/CharacterName";
import { CardEmoji, CharacterEmoji } from "@tcg/formatting/emojis";
import Pronouns from "@tcg/pronoun";
import mediaLinks from "@tcg/formatting/mediaLinks";
import { MessageCache } from "@src/tcgChatInteractions/messageCache";
import Game from "@tcg/game";
import Card, { Nature } from "@tcg/card";
import { TCGThread } from "@src/tcgChatInteractions/sendGameMessage";

const flammeStats = new Stats({
  [StatsEnum.HP]: 100.0,
  [StatsEnum.ATK]: 12.0,
  [StatsEnum.DEF]: 12.0,
  [StatsEnum.TrueDEF]: 0.0,
  [StatsEnum.SPD]: 12.0,
  [StatsEnum.Ability]: 0.0,
});

const a_pinnacleOfHumanitysMagic = new Card({
  title: "Pinnacle of Humanity's Magic",
  cardMetadata: { nature: Nature.Attack },
  description: ([stat]) =>
    `ATK+${stat} DEF+${stat} SPD+${stat}. Deal ${stat} DMG.`,
  emoji: CardEmoji.FLAMME_CARD,
  priority: 100,
  effects: [100],
  cosmetic: {
    cardGif: mediaLinks.flamme_pinnacle_gif,
  },
  cardAction: function (
    this: Card,
    { sendToGameroom, selfStat, flatSelfStat, basicAttack }
  ) {
    sendToGameroom(`The Pinnacle of Humanity's Magic is on display.`);
    flatSelfStat(1, StatsEnum.Ability);
    selfStat(0, StatsEnum.ATK);
    selfStat(0, StatsEnum.DEF);
    selfStat(0, StatsEnum.SPD);
    basicAttack(0);
  },
});

const Flamme = new CharacterData({
  characterName: CharacterName.Flamme,
  cosmetic: {
    pronouns: Pronouns.Feminine,
    emoji: CharacterEmoji.FLAMME,
    color: 0xde8a54,
    imageUrl: mediaLinks.flammePortrait,
  },
  stats: flammeStats,
  cards: flammeDeck,
  ability: {
    abilityName: "Founder of Humanity's Magic",
    abilityEffectString: `The Foundation of Humanity's Magic gets more developed for each Theory card you play.
        After playing 4 Theory cards, add 1 "Pinnacle of Humanity's Magic" to your Discard pile.
        *Pinnacle of Humanity's Magic*: Priority+100. ATK+**100** DEF+**100** SPD+**100**. Deal **100** DMG.`,
    subAbilities: [
      {
        name: "All-Knowing",
        description:
          "This character can see past the opponent's Mana Suppression.",
      },
    ],
    abilityAfterOwnCardUse: function (
      game: Game,
      characterIndex: number,
      _messageCache: MessageCache,
      card: Card
    ) {
      const character = game.getCharacter(characterIndex);
      if (card.cardMetadata.theory) {
        character.adjustStat(1, StatsEnum.Ability, game);
      }
    },
    abilityEndOfTurnEffect: function (
      game: Game,
      characterIndex: number,
      messageCache: MessageCache
    ) {
      const character = game.getCharacter(characterIndex);
      if (character.stats.stats.Ability === 4) {
        messageCache.push(
          "Flamme is close to a major discovery...",
          TCGThread.Gameroom
        );
        character.setStat(99, StatsEnum.Ability);
        messageCache.push(
          `*Pinnacle of Humanity's Magic* has been added to ${character.name}'s Discard pile.`,
          TCGThread.Gameroom
        );
        character.deck.discardPile.push(a_pinnacleOfHumanitysMagic.clone());
      }
    },
  },
  additionalMetadata: {
    deceitful: false,
    ignoreManaSuppressed: true,
    defenderDamageScaling: 1,
  },
});

export default Flamme;
</file>

<file path="src/tcg/characters/characterData/characters/Frieren.ts">
import { CharacterData } from "../characterData";
import Stats, { StatsEnum } from "@tcg/stats";
import frierenDeck from "@decks/FrierenDeck";
import { CharacterName } from "../../metadata/CharacterName";
import TimedEffect from "@tcg/timedEffect";
import Game from "@tcg/game";
import Card from "@tcg/card";
import { MessageCache } from "@src/tcgChatInteractions/messageCache";
import { TCGThread } from "@src/tcgChatInteractions/sendGameMessage";
import { CharacterEmoji } from "@tcg/formatting/emojis";
import Pronouns from "@tcg/pronoun";
import mediaLinks from "@tcg/formatting/mediaLinks";

const ANALYSIS_BOOST = 0.07;
const ANALYSIS_STACK_CAP = 10;

const frierenStats = new Stats({
  [StatsEnum.HP]: 100.0,
  [StatsEnum.ATK]: 12.0,
  [StatsEnum.DEF]: 12.0,
  [StatsEnum.TrueDEF]: 0.0,
  [StatsEnum.SPD]: 12.0,
  [StatsEnum.Ability]: 0.0,
});

const afterAttackEffect = function (
  game: Game,
  characterIndex: number,
  _messageCache: MessageCache
) {
  const character = game.getCharacter(characterIndex);
  character.setStat(0, StatsEnum.Ability);
};

const Frieren = new CharacterData({
  characterName: CharacterName.Frieren,
  cosmetic: {
    pronouns: Pronouns.Feminine,
    emoji: CharacterEmoji.FRIEREN,
    color: 0xc5c3cc,
    imageUrl: mediaLinks.frierenVangerisuCard,
  },
  stats: frierenStats,
  cards: frierenDeck,
  ability: {
    abilityName: "Analysis",
    abilityEffectString: `At the end of every turn, gain 1 Analysis stack.
        Whenever an "Analysis" move is used, gain 2 Analysis stacks.
        When an attack is used, its damage is increased by ${(ANALYSIS_BOOST * 100).toFixed(2)}% * the number of Analysis stacks.
        After an attack is used, Analysis stacks is reset to 0.
        A maximum of ${ANALYSIS_STACK_CAP} Analysis stacks can be held at any time.`,
    subAbilities: [
      {
        name: "Mana Suppression",
        description: "Hide the amount of HP this character has.",
      },
      {
        name: "Flamme's Teachings",
        description: "See past the opponent's Mana Suppression.",
      },
    ],
    abilityAfterOwnCardUse: function (
      game: Game,
      characterIndex: number,
      _messageCache: MessageCache,
      card: Card
    ) {
      const character = game.getCharacter(characterIndex);
      if (card.cardMetadata.analysis) {
        character.adjustStat(
          card.cardMetadata.analysis,
          StatsEnum.Ability,
          game
        );
        if (character.stats.stats.Ability > ANALYSIS_STACK_CAP) {
          character.setStat(ANALYSIS_STACK_CAP, StatsEnum.Ability);
        }
      }

      const postAnalysis = card.cardMetadata.postAnalysis;
      if (postAnalysis) {
        character.timedEffects.push(
          new TimedEffect({
            name: "Post Analysis",
            description: `At this turn's resolution, gain ${postAnalysis} Analysis stack.`,
            turnDuration: 1,
            metadata: { removableBySorganeil: false },
            endOfTimedEffectAction: (_game, _characterIndex, messageCache) => {
              messageCache.push(
                "Frieren performed her analysis.",
                TCGThread.Gameroom
              );
              character.adjustStat(postAnalysis, StatsEnum.Ability, game);
            },
          })
        );
      }
    },
    abilityAttackEffect: function (
      game: Game,
      characterIndex: number,
      _messageCache: MessageCache
    ) {
      const character = game.getCharacter(characterIndex);
      game.additionalMetadata.attackModifier[characterIndex] =
        1 + character.stats.stats[StatsEnum.Ability] * ANALYSIS_BOOST;
    },
    abilityAfterDirectAttackEffect: afterAttackEffect,
    abilityAfterTimedAttackEffect: afterAttackEffect,
    abilityEndOfTurnEffect: function (
      game: Game,
      characterIndex: number,
      messageCache: MessageCache
    ) {
      const character = game.getCharacter(characterIndex);
      if (character.stats.stats.Ability < ANALYSIS_STACK_CAP) {
        messageCache.push(
          "Frieren continues her Analysis.",
          TCGThread.Gameroom
        );
        character.adjustStat(1, StatsEnum.Ability, game);
      }
    },
  },
  additionalMetadata: {
    manaSuppressed: true,
    ignoreManaSuppressed: true,
    defenderDamageScaling: 1,
    methodeFindsCute: true,
  },
});

export default Frieren;
</file>

<file path="src/tcg/characters/characterData/characters/Himmel.ts">
import { CharacterData } from "../characterData";
import Stats, { StatsEnum } from "@tcg/stats";
import himmelDeck from "@decks/HimmelDeck";
import { CharacterName } from "../../metadata/CharacterName";
import { CharacterEmoji } from "@tcg/formatting/emojis";
import Pronouns from "@tcg/pronoun";
import mediaLinks from "@tcg/formatting/mediaLinks";

const HIMMEL_HERO_PARTY_DAMAGE_BONUS = 0.17;

const himmelStats = new Stats({
  [StatsEnum.HP]: 100.0,
  [StatsEnum.ATK]: 10.0,
  [StatsEnum.DEF]: 10.0,
  [StatsEnum.TrueDEF]: 0.0,
  [StatsEnum.SPD]: 16.0,
  [StatsEnum.Ability]: 0.0,
});

const Himmel = new CharacterData({
  characterName: CharacterName.Himmel,
  cosmetic: {
    pronouns: Pronouns.Masculine,
    emoji: CharacterEmoji.HIMMEL,
    color: 0xb4c9e7,
    imageUrl: mediaLinks.himmelPortrait,
  },
  stats: himmelStats,
  cards: himmelDeck,
  ability: {
    abilityName: "The Hero Party",
    abilityEffectString: `For each one of Frieren/Heiter/Eisen active as a timed effect,
        all of this character's attacks and timed effect attacks deal an additional ${(HIMMEL_HERO_PARTY_DAMAGE_BONUS * 100).toFixed(2)}% damage.`,
    abilityStartOfTurnEffect: function (
      this,
      game,
      characterIndex,
      _messageCache
    ) {
      const character = game.characters[characterIndex];
      character.setStat(
        character.timedEffects.length,
        StatsEnum.Ability,
        false
      );
    },
    abilityAttackEffect(game, characterIndex, _messageCache) {
      const character = game.getCharacter(characterIndex);
      game.additionalMetadata.attackModifier[characterIndex] =
        1 + HIMMEL_HERO_PARTY_DAMAGE_BONUS * character.timedEffects.length;
    },
  },
});

export default Himmel;
</file>

<file path="src/tcg/characters/characterData/characters/Laufen.ts">
import { CharacterData } from "../characterData";
import Stats, { StatsEnum } from "@tcg/stats";
import laufenDeck from "@decks/LaufenDeck";
import { CharacterName } from "../../metadata/CharacterName";
import { MessageCache } from "@src/tcgChatInteractions/messageCache";
import { CharacterEmoji } from "@tcg/formatting/emojis";
import Game from "@tcg/game";
import Pronouns from "@tcg/pronoun";
import mediaLinks from "@tcg/formatting/mediaLinks";

const laufenStats = new Stats({
  [StatsEnum.HP]: 90.0,
  [StatsEnum.ATK]: 10.0,
  [StatsEnum.DEF]: 8.0,
  [StatsEnum.TrueDEF]: 0.0,
  [StatsEnum.SPD]: 30.0,
  [StatsEnum.Ability]: 0.0,
});

const Laufen = new CharacterData({
  characterName: CharacterName.Laufen,
  cosmetic: {
    pronouns: Pronouns.Feminine,
    emoji: CharacterEmoji.LAUFEN,
    color: 0xcf7457,
    imageUrl: mediaLinks.laufenPortrait,
  },
  stats: laufenStats,
  cards: laufenDeck,
  ability: {
    abilityName: "Graze",
    abilityEffectString: `Reduce the opponent's attack damage by SPDDiff%.`,
    abilityStartOfTurnEffect: function (
      this,
      game,
      characterIndex,
      _messageCache
    ) {
      const character = game.characters[characterIndex];
      const opponent = game.getCharacter(1 - characterIndex);
      const spdDiff = character.stats.stats.SPD - opponent.stats.stats.SPD;

      character.setStat(spdDiff, StatsEnum.Ability, false);
    },
    abilityDefendEffect: (
      game: Game,
      characterIndex,
      _messageCache: MessageCache,
      _attackDamage
    ) => {
      const character = game.getCharacter(characterIndex);
      const opponent = game.getCharacter(1 - characterIndex);

      const spdDiff = character.stats.stats.SPD - opponent.stats.stats.SPD;
      const grazeReduction = Math.min(Math.max(spdDiff / 100, 0), 1);

      character.additionalMetadata.defenderDamageScaling = 1 - grazeReduction;
    },
  },
});

export default Laufen;
</file>

<file path="src/tcg/characters/characterData/characters/Linie.ts">
import { CharacterData } from "../characterData";
import Stats, { StatsEnum } from "@tcg/stats";
import linieDeck from "@decks/LinieDeck";
import { CharacterName } from "../../metadata/CharacterName";
import { MessageCache } from "@src/tcgChatInteractions/messageCache";
import { TCGThread } from "@src/tcgChatInteractions/sendGameMessage";
import { CharacterEmoji } from "@tcg/formatting/emojis";
import Pronouns from "@tcg/pronoun";
import mediaLinks from "@tcg/formatting/mediaLinks";

const LINIE_CHAIN_BONUS = 0.1;

const linieStats = new Stats({
  [StatsEnum.HP]: 95.0,
  [StatsEnum.ATK]: 13.0,
  [StatsEnum.DEF]: 10.0,
  [StatsEnum.TrueDEF]: 0.0,
  [StatsEnum.SPD]: 12.0,
  [StatsEnum.Ability]: 0.0,
});

const Linie = new CharacterData({
  characterName: CharacterName.Linie,
  cosmetic: {
    pronouns: Pronouns.Feminine,
    emoji: CharacterEmoji.LINIE,
    color: 0xf7c1b1,
    imageUrl: mediaLinks.liniePortrait,
  },
  stats: linieStats,
  cards: linieDeck,
  ability: {
    abilityName: "Chain Attack",
    abilityEffectString: `After this character uses an attack, gain 1 Chain stack.
        All attacks this character does has its damage increased by <#Chain>*${(LINIE_CHAIN_BONUS * 100).toFixed(2)}%.
        When this character does not attack in a turn, reset the count to 0.`,
    abilityAttackEffect: (game, characterIndex) => {
      const character = game.getCharacter(characterIndex);
      game.additionalMetadata.attackModifier[characterIndex] =
        1 + character.stats.stats[StatsEnum.Ability] * LINIE_CHAIN_BONUS;
    },
    abilityEndOfTurnEffect: (
      game,
      characterIndex,
      messageCache: MessageCache
    ) => {
      const character = game.getCharacter(characterIndex);
      if (
        character.additionalMetadata.attackedThisTurn ||
        character.additionalMetadata.timedEffectAttackedThisTurn
      ) {
        if (character.stats.stats.Ability === 0) {
          messageCache.push("Linie started her chain", TCGThread.Gameroom);
        } else {
          messageCache.push("Linie continued her chain", TCGThread.Gameroom);
        }
        character.adjustStat(1, StatsEnum.Ability, game);
      } else {
        if (character.stats.stats.Ability > 0) {
          messageCache.push("Linie ended her chain", TCGThread.Gameroom);
        }
        character.setStat(0, StatsEnum.Ability);
      }
    },
  },
});

export default Linie;
</file>

<file path="src/tcg/characters/characterData/characters/Methode.ts">
import Stats, { StatsEnum } from "@tcg/stats";
import { CharacterName } from "@tcg/characters/metadata/CharacterName";
import { CharacterData } from "@tcg/characters/characterData/characterData";
import Pronouns from "@tcg/pronoun";
import { CharacterEmoji } from "@tcg/formatting/emojis";
import mediaLinks from "@tcg/formatting/mediaLinks";
import methodeDeck from "@decks/MethodeDeck";
import { TCGThread } from "@src/tcgChatInteractions/sendGameMessage";

const methodeStats = new Stats({
  [StatsEnum.HP]: 100,
  [StatsEnum.ATK]: 12,
  [StatsEnum.DEF]: 12,
  [StatsEnum.TrueDEF]: 0,
  [StatsEnum.SPD]: 10,
  [StatsEnum.Ability]: 0,
});

const Methode = new CharacterData({
  characterName: CharacterName.Methode,
  cosmetic: {
    pronouns: Pronouns.Feminine,
    emoji: CharacterEmoji.METHODE,
    color: 0x7f78ac,
    imageUrl: mediaLinks.methodePortrait,
  },
  stats: methodeStats,
  cards: methodeDeck,
  ability: {
    abilityName: "Jack-of-all-trades",
    abilityEffectString: "Roll an extra die",
    subAbilities: [
      {
        name: '"I think you\'re cute"',
        description:
          "ATK+1 and DEF-1 against cute opponents on the first turn.",
      },
    ],
    abilityStartOfTurnEffect: (game, characterIndex, messageCache) => {
      const self = game.getCharacter(characterIndex);
      const opp = game.getCharacter(1 - characterIndex);

      if (!opp.additionalMetadata.methodeFindsCute) return;
      switch (game.turnCount) {
        case 1:
          {
            messageCache.push(
              `${self.name} finds ${opp.name} cute!`,
              TCGThread.Gameroom
            );
            self.adjustStat(1, StatsEnum.ATK, game);
            self.adjustStat(-1, StatsEnum.DEF, game);
          }
          break;
        case 2:
          {
            messageCache.push(
              `${self.name} redirects her focus from ${opp.name} back to the battle.`,
              TCGThread.Gameroom
            );
            self.adjustStat(-1, StatsEnum.ATK, game);
            self.adjustStat(1, StatsEnum.DEF, game);
          }
          break;
      }
    },
  },

  additionalMetadata: {
    rollsCount: 5,
  },
});

export default Methode;
</file>

<file path="src/tcg/characters/characterData/characters/Sein.ts">
import { CharacterData } from "../characterData";
import Stats, { StatsEnum } from "@tcg/stats";
import seinDeck from "@decks/SeinDeck";
import { CharacterName } from "../../metadata/CharacterName";
import { MessageCache } from "@src/tcgChatInteractions/messageCache";
import { TCGThread } from "@src/tcgChatInteractions/sendGameMessage";
import { CharacterEmoji } from "@tcg/formatting/emojis";
import Pronouns from "@tcg/pronoun";
import mediaLinks from "@tcg/formatting/mediaLinks";

const SEIN_BASE_HEALING = 2;
const SEIN_HEALING_RAMP = 0.1;

const seinStats = new Stats({
  [StatsEnum.HP]: 100.0,
  [StatsEnum.ATK]: 11.0,
  [StatsEnum.DEF]: 11.0,
  [StatsEnum.TrueDEF]: 0.0,
  [StatsEnum.SPD]: 10.0,
  [StatsEnum.Ability]: 0.0,
});

const Sein = new CharacterData({
  characterName: CharacterName.Sein,
  cosmetic: {
    pronouns: Pronouns.Masculine,
    emoji: CharacterEmoji.SEIN,
    color: 0xa3caca,
    imageUrl: mediaLinks.seinVangerisuCard,
  },
  stats: seinStats,
  cards: seinDeck,
  ability: {
    abilityName: "Goddess' Blessing",
    abilityEffectString: `Heal for ${SEIN_BASE_HEALING}HP + ${SEIN_BASE_HEALING} * (Turn Count * ${(SEIN_HEALING_RAMP * 100).toFixed(2)}%) at the end of every turn.
        This character can be healed past their maxHP.`,
    abilityStartOfTurnEffect: function (
      this,
      game,
      characterIndex,
      _messageCache
    ) {
      const character = game.characters[characterIndex];
      const healing =
        SEIN_BASE_HEALING +
        SEIN_BASE_HEALING * (game.turnCount * SEIN_HEALING_RAMP);

      character.setStat(healing, StatsEnum.Ability, false);
    },
    abilityEndOfTurnEffect: (
      game,
      characterIndex,
      messageCache: MessageCache
    ) => {
      messageCache.push(
        "Sein sought the Goddess' Blessings.",
        TCGThread.Gameroom
      );
      const character = game.characters[characterIndex];
      character.adjustStat(character.stats.stats.Ability, StatsEnum.HP, game);
    },
  },
  additionalMetadata: {
    overheal: true,
  },
});

export default Sein;
</file>

<file path="src/tcg/characters/characterData/characters/Sense.ts">
import { CharacterData } from "../characterData";
import Stats, { StatsEnum } from "@tcg/stats";
import senseDeck from "@decks/SenseDeck";
import { CharacterName } from "../../metadata/CharacterName";
import { CharacterEmoji } from "@tcg/formatting/emojis";
import { MessageCache } from "@src/tcgChatInteractions/messageCache";
import { TCGThread } from "@src/tcgChatInteractions/sendGameMessage";
import Pronouns from "@tcg/pronoun";
import mediaLinks from "@tcg/formatting/mediaLinks";
// import config from "@src/config";

// config module not found for some reason
// const PROCTOR_STACK_COUNT = config.debugMode ? 1 : 15;
const PROCTOR_STACK_COUNT = 15;
const PROCTOR_STACK_ATTACK_DEDUCTION = 1;
const TEA_TIME_STACK_TURN_SKIP = 3;

const senseStats = new Stats({
  [StatsEnum.HP]: 90.0,
  [StatsEnum.ATK]: 10.0,
  [StatsEnum.DEF]: 12.0,
  [StatsEnum.TrueDEF]: 0.0,
  [StatsEnum.SPD]: 8.0,
  [StatsEnum.Ability]: 0.0,
});

const Sense = new CharacterData({
  characterName: CharacterName.Sense,
  cosmetic: {
    pronouns: Pronouns.Feminine,
    emoji: CharacterEmoji.SENSE,
    color: 0xb6a493,
    imageUrl: mediaLinks.sensePortrait,
  },
  stats: senseStats,
  cards: senseDeck,
  ability: {
    abilityName: "Proctor",
    abilityEffectString: `Every turn this character doesn't attack, gain 1 observation. Every turn this character attacks, lose ${PROCTOR_STACK_ATTACK_DEDUCTION} observation. (min 0)
	This character wins when the test is over after ${PROCTOR_STACK_COUNT} observations.`,
    subAbilities: [
      {
        name: "Tea Time",
        description: `When this character has ${TEA_TIME_STACK_TURN_SKIP} Tea Time Snacks, skip the turn for both characters and eat ${TEA_TIME_STACK_TURN_SKIP} Tea Time Snacks.`,
      },
    ],
    abilityAfterOwnCardUse: function (
      game,
      characterIndex,
      messageCache: MessageCache,
      card
    ) {
      const character = game.getCharacter(characterIndex);
      const opponent = game.getCharacter(1 - characterIndex);
      if (card.cardMetadata.teaTime) {
        character.additionalMetadata.senseTeaTimeStacks ??= 0;

        character.additionalMetadata.senseTeaTimeStacks +=
          card.cardMetadata.teaTime;
        if (
          character.additionalMetadata.senseTeaTimeStacks >=
          TEA_TIME_STACK_TURN_SKIP
        ) {
          messageCache.push(
            "Sense holds a tea party! Both characters take a turn to enjoy the tea.",
            TCGThread.Gameroom
          );
          character.additionalMetadata.senseTeaTimeStacks -=
            TEA_TIME_STACK_TURN_SKIP;
          character.skipTurn = true;
          opponent.skipTurn = true;
        }
      }
    },
    abilityEndOfTurnEffect: (
      game,
      characterIndex,
      messageCache: MessageCache
    ) => {
      const character = game.characters[characterIndex];
      if (character.additionalMetadata.attackedThisTurn) {
        messageCache.push("Sense went on the offensive!", TCGThread.Gameroom);
        const newAbilityCount = Math.max(
          0,
          character.stats.stats.Ability - PROCTOR_STACK_ATTACK_DEDUCTION
        );
        character.setStat(newAbilityCount, StatsEnum.Ability);
      } else {
        messageCache.push(
          `${character.name} continued to observe peacefully.`,
          TCGThread.Gameroom
        );
        character.adjustStat(1, StatsEnum.Ability, game);

        if (character.stats.stats.Ability === PROCTOR_STACK_COUNT) {
          messageCache.push(
            `# ${character.name} has finished proctoring ${character.cosmetic.pronouns.possessive} test. The examinee did not pass in time.`,
            TCGThread.Gameroom
          );
          game.additionalMetadata.forfeited[1 - characterIndex] = true;
        }
      }
    },
  },
  additionalMetadata: {
    senseTeaTimeStacks: 0,
  },
});

export default Sense;
</file>

<file path="src/tcg/characters/characterData/characters/Serie.ts">
import { CharacterData } from "../characterData";
import serieDeck from "@decks/SerieDeck";
import Stats, { StatsEnum } from "@tcg/stats";
import { CharacterName } from "../../metadata/CharacterName";
import { CharacterEmoji } from "@tcg/formatting/emojis";
import { MessageCache } from "@src/tcgChatInteractions/messageCache";
import { TCGThread } from "@src/tcgChatInteractions/sendGameMessage";
import Game from "@tcg/game";
import Pronouns from "@tcg/pronoun";
import mediaLinks from "@tcg/formatting/mediaLinks";

const SERIE_TOYING_DAMAGE_BONUS = 0.3;

const serieStats = new Stats({
  [StatsEnum.HP]: 100.0,
  [StatsEnum.ATK]: 14.0,
  [StatsEnum.DEF]: 10.0,
  [StatsEnum.TrueDEF]: 0.0,
  [StatsEnum.SPD]: 10.0,
  [StatsEnum.Ability]: 0.0,
});

const afterAttackEffect = function (
  game: Game,
  characterIndex: number,
  _messageCache: MessageCache
) {
  const character = game.getCharacter(characterIndex);
  if (!character.additionalMetadata.serieToyingTurn) {
    character.additionalMetadata.serieToyingNextTurn = true;
  }
};

const Serie = new CharacterData({
  characterName: CharacterName.Serie,
  cosmetic: {
    pronouns: Pronouns.Feminine,
    emoji: CharacterEmoji.SERIE,
    color: 0xe8b961,
    imageUrl: mediaLinks.serieVangerisuCard,
  },
  stats: serieStats,
  cards: serieDeck,
  ability: {
    abilityName: "Toying Around",
    abilityEffectString: `Any attack used by this character has its DMG+${(SERIE_TOYING_DAMAGE_BONUS * 100).toFixed(2)}%. 
      The turn after this character performs any attack, DMG-${(SERIE_TOYING_DAMAGE_BONUS * 100).toFixed(2)}%.`,
    subAbilities: [
      {
        name: "Mana Suppression",
        description: `Hide the amount of HP this character has.`,
      },
      {
        name: "Serie's Intuition",
        description: `See past the opponent's Mana Suppression.`,
      },
    ],
    abilityStartOfTurnEffect(game, characterIndex, messageCache) {
      const character = game.getCharacter(characterIndex);
      if (character.additionalMetadata.serieToyingNextTurn) {
        messageCache.push("## Serie acts aloof.", TCGThread.Gameroom);
        character.additionalMetadata.serieToyingTurn = true;
        character.additionalMetadata.serieToyingNextTurn = false;
        character.setStat(
          1 - SERIE_TOYING_DAMAGE_BONUS,
          StatsEnum.Ability,
          false
        );
      } else {
        character.additionalMetadata.serieToyingTurn = false;
        character.setStat(
          1 + SERIE_TOYING_DAMAGE_BONUS,
          StatsEnum.Ability,
          false
        );
      }
    },
    abilityAttackEffect(game, characterIndex, _messageCache) {
      const character = game.getCharacter(characterIndex);
      if (character.additionalMetadata.serieToyingTurn) {
        game.additionalMetadata.attackModifier[characterIndex] =
          1 - SERIE_TOYING_DAMAGE_BONUS;
      } else {
        game.additionalMetadata.attackModifier[characterIndex] =
          1 + SERIE_TOYING_DAMAGE_BONUS;
      }
    },
    abilityAfterDirectAttackEffect: afterAttackEffect,
    abilityAfterTimedAttackEffect: afterAttackEffect,
  },
  additionalMetadata: {
    manaSuppressed: true,
    ignoreManaSuppressed: true,
    serieToyingNextTurn: false,
    serieToyingTurn: false,
    methodeFindsCute: true,
  },
});

export default Serie;
</file>

<file path="src/tcg/characters/characterData/characters/Stark.ts">
import { CharacterData } from "../characterData";
import Stats, { StatsEnum } from "@tcg/stats";
import starkDeck from "@decks/StarkDeck";
import { CharacterName } from "../../metadata/CharacterName";
import { CharacterEmoji } from "@tcg/formatting/emojis";
import Pronouns from "@tcg/pronoun";
import mediaLinks from "@tcg/formatting/mediaLinks";

const starkStats = new Stats({
  [StatsEnum.HP]: 125.0,
  [StatsEnum.ATK]: 10.0,
  [StatsEnum.DEF]: 10.0,
  [StatsEnum.TrueDEF]: 0.0,
  [StatsEnum.SPD]: 8.0,
  [StatsEnum.Ability]: 0.0,
});

const Stark = new CharacterData({
  characterName: CharacterName.Stark,
  cosmetic: {
    pronouns: Pronouns.Masculine,
    emoji: CharacterEmoji.STARK,
    color: 0xb30c0c,
    imageUrl: mediaLinks.starkPortrait,
  },
  stats: starkStats,
  cards: starkDeck,
  ability: {
    abilityName: "Bravest Coward",
    abilityEffectString: `Using attacks while your (Resolve) is negative reduces its DMG by 20%.
        Using attacks while your (Resolve) is positive increases its DMG by 20%.
        Your attacks stay the same when your (Resolve) is 0.`,
    abilityAfterOwnCardUse: function (
      game,
      characterIndex,
      _messageCache,
      card
    ) {
      const character = game.getCharacter(characterIndex);
      if (card.cardMetadata.resolve) {
        character.adjustStat(
          card.cardMetadata.resolve,
          StatsEnum.Ability,
          game
        );
      }
    },
    abilityAttackEffect: function (game, characterIndex) {
      const character = game.getCharacter(characterIndex);
      if (character.stats.stats.Ability > 0) {
        game.additionalMetadata.attackModifier[characterIndex] = 1.2;
      } else if (character.stats.stats.Ability < 0) {
        game.additionalMetadata.attackModifier[characterIndex] = 0.8;
      } else {
        game.additionalMetadata.attackModifier[characterIndex] = 1.0;
      }
    },
  },
});

export default Stark;
</file>

<file path="src/tcg/characters/characterData/characters/Stille.ts">
import { CharacterData } from "../characterData";
import stilleDeck from "@decks/StilleDeck";
import Stats, { StatsEnum } from "@tcg/stats";
import Rolls from "@tcg/util/rolls";
import { CharacterName } from "../../metadata/CharacterName";
import { MessageCache } from "@src/tcgChatInteractions/messageCache";
import { TCGThread } from "@src/tcgChatInteractions/sendGameMessage";
import { CharacterEmoji } from "@tcg/formatting/emojis";
import Pronouns from "@tcg/pronoun";
import mediaLinks from "@tcg/formatting/mediaLinks";

const STILLE_REFLECT_SCALE = 0.8;

const stilleStats = new Stats({
  [StatsEnum.HP]: 20.0,
  [StatsEnum.ATK]: 1.0,
  [StatsEnum.DEF]: 20.0,
  [StatsEnum.TrueDEF]: 0.0,
  [StatsEnum.SPD]: 80.0,
  [StatsEnum.Ability]: 0.0,
});

const Stille = new CharacterData({
  characterName: CharacterName.Stille,
  cosmetic: {
    pronouns: Pronouns.Impersonal,
    emoji: CharacterEmoji.STILLE,
    color: 0xe74c3c,
    imageUrl: mediaLinks.stillePortrait,
  },
  stats: stilleStats,
  cards: stilleDeck,
  ability: {
    abilityName: "High-speed Escape",
    abilityEffectString: `When the opponent attacks, roll a D100. 
        If the result is less than the character's SPD minus the opponent's SPD, ignore the attack.
        Afterwards, attack the opponent with DMG equivalent to ${(STILLE_REFLECT_SCALE * 100).toFixed(0)}% of (opponent's ATK + opponent's move DMG).`,
    subAbilities: [
      {
        name: "Birdwatching",
        description: `Both characters don't have access to default card options (Discard/Wait).`,
      },
    ],
    abilityStartOfTurnEffect: (
      game,
      characterIndex,
      _messageCache: MessageCache
    ) => {
      const character = game.characters[characterIndex];
      const opponent = game.getCharacter(1 - characterIndex);
      const spdDiff = character.stats.stats.SPD - opponent.stats.stats.SPD;

      character.setStat(100 - spdDiff, StatsEnum.Ability, false);
      character.additionalMetadata.accessToDefaultCardOptions = false;
      opponent.additionalMetadata.accessToDefaultCardOptions = false;
    },
    abilityDefendEffect: (
      game,
      characterIndex,
      messageCache: MessageCache,
      _attackDamage
    ) => {
      const character = game.getCharacter(characterIndex);
      const opponent = game.getCharacter(1 - characterIndex);

      const roll = Rolls.rollD100();
      const spdDiff = character.stats.stats.SPD - opponent.stats.stats.SPD;
      messageCache.push(`## **SPD diff**: ${spdDiff}`, TCGThread.Gameroom);
      messageCache.push(`# Roll: ${roll}`, TCGThread.Gameroom);

      if (roll < spdDiff) {
        messageCache.push("## Stille evaded the attack!", TCGThread.Gameroom);
        game.additionalMetadata.attackMissed[1 - characterIndex] = true;
      } else {
        messageCache.push(
          "## Stille failed to evade the attack!",
          TCGThread.Gameroom
        );
        game.additionalMetadata.attackMissed[1 - characterIndex] = false;
      }
    },
    abilityCounterEffect: (
      game,
      characterIndex,
      messageCache: MessageCache,
      attackDamage
    ) => {
      const opponent = game.getCharacter(1 - characterIndex);

      if (game.additionalMetadata.attackMissed[1 - characterIndex]) {
        messageCache.push(
          "## The Stille's high speed escape reflected the opponent's damage!",
          TCGThread.Gameroom
        );
        game.attack({
          attackerIndex: characterIndex,
          damage:
            STILLE_REFLECT_SCALE * (opponent.stats.stats.ATK + attackDamage),
          isTimedEffectAttack: false,
        });
      }
    },
  },
  additionalMetadata: {
    accessToDefaultCardOptions: false,
  },
});

export default Stille;
</file>

<file path="src/tcg/characters/characterData/characters/Ubel.ts">
import { CharacterData } from "../characterData";
import { UbelHit } from "@tcg/additionalMetadata/characterAdditionalMetadata";
import ubelDeck, { empathyFailureName } from "@decks/UbelDeck";
import Stats, { StatsEnum } from "@tcg/stats";
import Game from "@tcg/game";
import Card, { Nature } from "@tcg/card";
import Rolls from "@tcg/util/rolls";
import Character from "@tcg/character";
import { CharacterName } from "../../metadata/CharacterName";
import { MessageCache } from "@src/tcgChatInteractions/messageCache";
import { TCGThread } from "@src/tcgChatInteractions/sendGameMessage";
import { CharacterEmoji } from "@tcg/formatting/emojis";
import { GameMessageContext } from "@tcg/gameContextProvider";
import Pronouns from "@tcg/pronoun";
import mediaLinks from "@tcg/formatting/mediaLinks";

const PIERCE_FACTOR = 1.0;

const ubelStats = new Stats({
  [StatsEnum.HP]: 90.0,
  [StatsEnum.ATK]: 12.0,
  [StatsEnum.DEF]: 8.0,
  [StatsEnum.TrueDEF]: 0.0,
  [StatsEnum.SPD]: 14.0,
  [StatsEnum.Ability]: 0.0,
});

function checkForEffects(effects: string[]): Record<string, boolean> {
  const effectsListToCheckFor = ["Sorganeil", "Rushdown", "Recompose"];
  const presence = effectsListToCheckFor.map((effect) =>
    effects.includes(effect)
  );
  const result: Record<string, boolean> = {
    Sorganeil: presence[0],
    Rushdown: presence[1],
    Recompose: presence[2],
  };
  return result;
}

function missAttack(
  context: GameMessageContext,
  card: Card,
  failureRate: number,
  hitIntoShield: boolean
) {
  const { game, selfIndex: characterIndex, messageCache } = context;
  // Non Ubel slashing sureHits get treated normally
  if (failureRate === 0) {
    card.cardAction(context);
  } else {
    const character = game.getCharacter(characterIndex);

    messageCache.push("The attack cannot connect!", TCGThread.Gameroom);

    if (!hitIntoShield) {
      messageCache.push("Yet Übel keeps rushing forward!", TCGThread.Gameroom);

      const atkSpdBuff = card.calculateEffectValue(card.effects[1]);
      character.adjustStat(atkSpdBuff, StatsEnum.ATK, game);
      character.adjustStat(atkSpdBuff, StatsEnum.SPD, game);
    }
  }
}

function attackWhileRecomposing(
  character: Character,
  messageCache: MessageCache
) {
  messageCache.push(
    `${character.name} is recomposing herself and can't attack`,
    TCGThread.Gameroom
  );
}

function playOffensiveCard(
  context: GameMessageContext,
  card: Card,
  failureRate: number
): void {
  // check for always hitting empathy attacks
  const { messageCache } = context;
  if (failureRate === 0) {
    card.cardAction?.(context);
    return;
  }

  const luckRoll = Rolls.rollD100();
  messageCache.push(
    `## **Missing chances:** ${failureRate}%`,
    TCGThread.Gameroom
  );
  messageCache.push(`# Luck roll: ${luckRoll}`, TCGThread.Gameroom);
  if (luckRoll < failureRate) {
    missAttack(context, card, failureRate, false);
  } else {
    messageCache.push("The attack connects!", TCGThread.Gameroom);
    card.cardAction?.(context);
  }
}

function wrapEmpathizedCard(
  character: Character,
  card: Card,
  messageCache: MessageCache
): void {
  messageCache.push(
    `${character.name} tries to empathize with ${character.cosmetic.pronouns.possessive} opponent...`,
    TCGThread.Gameroom
  );

  //empathy before the minimum turn number
  if (card.title == empathyFailureName) {
    return;
  }

  messageCache.push(
    `${character.name} acquired a new magic!`,
    TCGThread.Gameroom
  );
}

const Ubel = new CharacterData({
  characterName: CharacterName.Ubel,
  cosmetic: {
    pronouns: Pronouns.Feminine,
    emoji: CharacterEmoji.UBEL,
    color: 0x3c5502,
    imageUrl: mediaLinks.ubelPortrait,
  },
  stats: ubelStats,
  cards: ubelDeck,
  ability: {
    abilityName: "Reckless",
    abilityEffectString: `Übel's slashing attacks ignore ${PIERCE_FACTOR * 100}% the opponent's defense stats, but are blocked by defensive moves.`,

    // same turn surehit effect changes
    abilityAfterOpponentsMoveEffect: function (
      game: Game,
      characterIndex: number,
      messageCache: MessageCache,
      card: Card
    ) {
      const character = game.getCharacter(characterIndex);
      const opponent = game.getCharacter(1 - characterIndex);
      const effects = character.timedEffects.map((effect) => effect.name);
      const activeEffects = checkForEffects(effects);

      switch (card.cardMetadata.nature) {
        case "Attack":
          if (!activeEffects.Recompose) {
            character.additionalMetadata.ubelSureHit = UbelHit.SureHit;
            messageCache.push(
              `${opponent.name} is wide-open!`,
              TCGThread.Gameroom
            );
          }
          break;
        case "Defense":
          character.additionalMetadata.ubelSureHit = UbelHit.SureMiss;
          messageCache.push(
            `${character.name} can't cut through this!`,
            TCGThread.Gameroom
          );
          break;
        default:
          if (
            !activeEffects.Recompose &&
            !activeEffects.Rushdown &&
            !activeEffects.Sorganeil
          ) {
            character.additionalMetadata.ubelSureHit = UbelHit.Regular;
          }
      }
    },

    // new turn surehit effect changes
    abilityStartOfTurnEffect: function (game, characterIndex, _messageCache) {
      const character = game.getCharacter(characterIndex);
      const effects = character.timedEffects.map((effect) => effect.name);
      const activeEffects = checkForEffects(effects);

      if (activeEffects.Sorganeil || activeEffects.Rushdown) {
        character.additionalMetadata.ubelSureHit = UbelHit.SureHit;
      } else if (activeEffects.Recompose) {
        character.additionalMetadata.ubelSureHit = UbelHit.SureMiss;
      } else {
        if (game.additionalMetadata.lastUsedCards[1 - characterIndex]) {
          if (
            game.additionalMetadata.lastUsedCards[1 - characterIndex]
              .cardMetadata.nature != "Attack"
          ) {
            character.additionalMetadata.ubelSureHit = UbelHit.Regular;
          } else {
            character.additionalMetadata.ubelSureHit = UbelHit.SureHit;
          }
        }
      }
    },

    // attacks should potentially fail
    abilityOwnCardEffectWrapper: function (
      context: GameMessageContext,
      card: Card
    ) {
      const { self: character, messageCache } = context;
      const effects = character.timedEffects;
      const effectsNames = effects.map((eff) => eff.name);
      const activeEffects = checkForEffects(effectsNames);

      //routine for empathized cards, all cases are treated within the function itself
      if (card.empathized) {
        wrapEmpathizedCard(character, card, messageCache);
      }

      //utils and default cards don't care about hitting status
      if (card.cardMetadata.nature != Nature.Attack) {
        card.cardAction?.(context);
        return;
      }

      //attacks
      const failureRate = card.cardMetadata.ubelFailureRate ?? 0;
      switch (character.additionalMetadata.ubelSureHit) {
        case UbelHit.Regular:
          playOffensiveCard(context, card, failureRate);
          break;
        case UbelHit.SureHit:
          card.cardAction?.(context);
          break;
        case UbelHit.SureMiss:
          // defensive move
          if (!activeEffects.Recompose) {
            missAttack(context, card, failureRate, true);
            return;
          }
          // Recomposing
          if (activeEffects.Sorganeil) {
            card.cardAction?.(context);
          } else {
            attackWhileRecomposing(character, messageCache);
          }
          break;
      }
    },
  },
  additionalMetadata: {
    ubelSureHit: UbelHit.Regular,
    ubelSlashMovesPierceFactor: PIERCE_FACTOR,
  },
});

export default Ubel;
</file>

<file path="src/tcg/characters/characterData/characters/Wirbel.ts">
import { CharacterData } from "../characterData";
import Stats, { StatsEnum } from "@tcg/stats";
import wirbelDeck from "@tcg/decks/WirbelDeck";
import { CharacterName } from "../../metadata/CharacterName";
import { CharacterEmoji } from "@tcg/formatting/emojis";
import { MessageCache } from "@src/tcgChatInteractions/messageCache";
import { TCGThread } from "@src/tcgChatInteractions/sendGameMessage";
import Pronouns from "@tcg/pronoun";
import mediaLinks from "@tcg/formatting/mediaLinks";
import Game from "@tcg/game";

const WIRBEL_RESOLVE_DMG_BONUS = 0.2;
const WIRBEL_RESOLVE_DMG_CAP = 0.2;

const wirbelStats = new Stats({
  [StatsEnum.HP]: 100.0,
  [StatsEnum.ATK]: 13.0,
  [StatsEnum.DEF]: 10.0,
  [StatsEnum.TrueDEF]: 0.0,
  [StatsEnum.SPD]: 13.0,
  [StatsEnum.Ability]: 0.0,
});

const Wirbel = new CharacterData({
  characterName: CharacterName.Wirbel,
  cosmetic: {
    pronouns: Pronouns.Masculine,
    emoji: CharacterEmoji.WIRBEL,
    color: 0xa4a8b9,
    imageUrl: mediaLinks.wirbelPortrait,
  },
  stats: wirbelStats,
  cards: wirbelDeck,
  ability: {
    abilityName: "Resolve to Kill",
    abilityEffectString: `When the opponent attacks you while your TrueDEF is >0, increase your ATK by ${(WIRBEL_RESOLVE_DMG_BONUS * 100).toFixed(2)}% of the attack's damage, to a maximum of ${(WIRBEL_RESOLVE_DMG_CAP * 100).toFixed(2)}% of your TrueDEF`,
    abilityDefendEffect: (
      game: Game,
      characterIndex: number,
      messageCache: MessageCache,
      attackDamage: number
    ) => {
      const character = game.getCharacter(characterIndex);

      if (character.stats.stats.TrueDEF > 0) {
        const resolveAttackGain = Math.min(
          attackDamage * WIRBEL_RESOLVE_DMG_BONUS,
          character.stats.stats.TrueDEF * WIRBEL_RESOLVE_DMG_CAP
        );

        messageCache.push(
          `Wirbel feels the need to steel his resolve.`,
          TCGThread.Gameroom
        );
        character.adjustStat(resolveAttackGain, StatsEnum.ATK, game);
      }
    },
  },
});

export default Wirbel;
</file>

<file path="src/tcg/characters/characterData/characterUtil/auraPlatoon.ts">
export enum AuraPlatoon {
  Swordsmen = "Swordsmen",
  Shieldbearers = "Shieldbearers",
  Archers = "Archers",
}

export const auraPlatoonToEmoji: Record<AuraPlatoon, string> = {
  [AuraPlatoon.Swordsmen]: "⚔️",
  [AuraPlatoon.Shieldbearers]: "🛡️",
  [AuraPlatoon.Archers]: "🏹",
};
</file>

<file path="src/tcg/characters/characterData/characterData.ts">
import Pronouns from "@tcg/pronoun";
import { CharacterName } from "@tcg/characters/metadata/CharacterName";
import { Ability } from "@tcg/ability";
import Stats from "@tcg/stats";
import Card from "@tcg/card";
import { CharacterAdditionalMetadata } from "@tcg/additionalMetadata/characterAdditionalMetadata";
import { CharacterEmoji } from "@tcg/formatting/emojis";

const defaultMetadata: CharacterAdditionalMetadata = {
  manaSuppressed: false,
  ignoreManaSuppressed: false,
  deceitful: false,
  attackedThisTurn: false,
  timedEffectAttackedThisTurn: false,
  accessToDefaultCardOptions: true,
  defenderDamageScaling: 1.0,
  pierceFactor: 0,
  forcedDiscards: 0,
  rollsCount: 4,
  methodeFindsCute: false,
  auraPlatoonQueue: [],
  auraArmyDamageAbsorbtion: 0,

  hidden: false,
  publicDiscards: false,
};

export interface CharacterCosmetic {
  pronouns: Pronouns;
  emoji: CharacterEmoji;
  color: number;
  imageUrl: string;
}

export interface CharacterDataProps {
  characterName: CharacterName;
  cosmetic: CharacterCosmetic;
  stats: Stats;
  cards: { card: Card; count: number }[];
  ability: Ability;
  additionalMetadata?: Partial<CharacterAdditionalMetadata>;
}

export class CharacterData {
  characterName: CharacterName;
  cosmetic: CharacterCosmetic;
  stats: Stats;
  cards: { card: Card; count: number }[];
  ability: Ability;

  additionalMetadata: CharacterAdditionalMetadata;

  constructor(characterDataProps: CharacterDataProps) {
    this.characterName = characterDataProps.characterName;
    this.cosmetic = characterDataProps.cosmetic;
    this.stats = characterDataProps.stats;
    this.cards = characterDataProps.cards;
    this.ability = characterDataProps.ability;
    this.additionalMetadata = {
      ...defaultMetadata,
      ...characterDataProps.additionalMetadata,
    };
  }

  clone(): CharacterData {
    return new CharacterData({
      characterName: this.characterName,
      cosmetic: this.cosmetic,
      stats: this.stats.clone(),
      cards: this.cards,
      ability: { ...this.ability },
      additionalMetadata: { ...this.additionalMetadata },
    });
  }
}
</file>

<file path="src/tcg/characters/metadata/CharacterName.ts">
export enum CharacterName {
  Aura = "Aura",
  Denken = "Denken",
  Edel = "Edel",
  Fern = "Fern",
  Flamme = "Flamme",
  Frieren = "Frieren",
  Himmel = "Himmel",
  Laufen = "Laufen",
  Linie = "Linie",
  Methode = "Methode",
  Sein = "Sein",
  Sense = "Sense",
  Serie = "Serie",
  Stark = "Stark",
  Stille = "Stille",
  Ubel = "Übel",
  Wirbel = "Wirbel",
}
</file>

<file path="src/tcg/characters/characterList.ts">
import { CharacterData } from "@tcg/characters/characterData/characterData";
import { CharacterName } from "@tcg/characters/metadata/CharacterName";
import Denken from "@characters/Denken";
import Edel from "@characters/Edel";
import Fern from "@characters/Fern";
import Flamme from "@characters/Flamme";
import Frieren from "@characters/Frieren";
import Himmel from "@characters/Himmel";
import Laufen from "@characters/Laufen";
import Linie from "@characters/Linie";
import Methode from "@characters/Methode";
import Sein from "@characters/Sein";
import Sense from "@characters/Sense";
import Serie from "@characters/Serie";
import Stark from "@characters/Stark";
import Stille from "@characters/Stille";
import Ubel from "@characters/Ubel";
import Wirbel from "@characters/Wirbel";
import Aura from "./characterData/characters/Aura";

export const CHARACTER_MAP: Record<CharacterName, CharacterData> = {
  [CharacterName.Aura]: Aura,
  [CharacterName.Denken]: Denken,
  [CharacterName.Edel]: Edel,
  [CharacterName.Fern]: Fern,
  [CharacterName.Flamme]: Flamme,
  [CharacterName.Frieren]: Frieren,
  [CharacterName.Himmel]: Himmel,
  [CharacterName.Laufen]: Laufen,
  [CharacterName.Linie]: Linie,
  [CharacterName.Methode]: Methode,
  [CharacterName.Sein]: Sein,
  [CharacterName.Sense]: Sense,
  [CharacterName.Serie]: Serie,
  [CharacterName.Stark]: Stark,
  [CharacterName.Stille]: Stille,
  [CharacterName.Ubel]: Ubel,
  [CharacterName.Wirbel]: Wirbel,
} as const;

export const CHARACTER_LIST: CharacterData[] = Object.values(CHARACTER_MAP);
export const VISIBLE_CHARACTERS = CHARACTER_LIST.filter(
  (char) => char.additionalMetadata.hidden !== true
);
</file>

</files>
